#!/bin/ksh -l
################################################################################
####  UNIX Script Documentation Block
#                      .                                             .
# Script name:       exrap_analysis_sh.ecf
# Script description:  runs the GSI and boundary update for the RAP cycle
# Author:   Ming Hu / Geoff Manikin / Julia Zhu  Org: EMC          Date: 2011-10-01
# 2011-10-01  M Hu / G Manikin / J Zhu

set -x

cd $DATA

# Set up some constants

export NDATE=${NDATE:-/nwprod/util/exec/ndate}
START_TIME=`$NDATE 9 $PDY$cyc`
echo $START_TIME >STARTTIME

# Compute date & time components for the analysis time
ymd=`echo ${START_TIME} | cut -c1-8`
ymdh=`echo ${START_TIME} | cut -c1-10`
mdh=`echo ${START_TIME} | cut -c5-10`
hh=`echo ${START_TIME} | cut -c9-10`

### Now run the GSI
# Set up some NCEP loadlevelor environment variables
export SPINLOOPTIME=10000
export YIELDLOOPTIME=40000
export AIXTHREAD_SCOPE=S
export MALLOCMULTIHEAP=true
export MEMORY_AFFINITY=MCM
export BIND_TASKS=YES

. /usrx/local/Modules/default/init/ksh
module load ibmpe
#export LD_LIBRARY_PATH=/usrx/local/NetCDF/3.6.3/lib
export MP_EAGER_LIMIT=165536
export MP_COREFILE_FORMAT=lite
export MP_EUIDEVELOP=min
export MP_EUILIB=us
export MP_MPILIB=mpich2

export MP_LABELIO=yes
export MP_USE_BULK_XFER=yes
export MP_SHARED_MEMORY=yes

export MPICH_ALLTOALL_THROTTLE=0
export KMP_STACKSIZE=1024m
export MP_TASK_AFFINITY=cpu:2
export OMP_NUM_THREADS=2

# Set to yes for faster collective ops (mpi_reduce)
# but may not yield bitwise identical results from
# run to run when yes.
export MP_COLLECTIVE_OFFLOAD=yes

# Compute date & time components for the analysis time
YYYY=`echo ${START_TIME} | cut -c1-4`
MM=`echo ${START_TIME} | cut -c5-6`
DD=`echo ${START_TIME} | cut -c7-8`
HH=`echo ${START_TIME} | cut -c9-10`
yy=`echo ${START_TIME} | cut -c3-4`
YYYYMMDDHH=${YYYY}${MM}${DD}${HH}
YYYYMMDD=${YYYY}${MM}${DD}

# Compute date & time components for the analysis time minus 1 day
DDm1=`$NDATE -24 $START_TIME`
YMDm1=`echo ${DDm1} | cut -c1-8`

# Bring over background field
time_str=${YYYY}-${MM}-${DD}_${HH}_00_00
echo " time_str = ${time_str}"

# first step is to make sure that we aren't attempting a cold start
#   at a cycle time that won't be possible.   These are all cycle times
#   not divisible by 3, as we use boundary files which are generated by
#   3-hrly GFS output

let mod=${HH}%3
echo mod 
echo $mod 
if [[ ${mod} -ne '0' ]]; then
  echo 'a cold start will not be possible this cycle if needed'
fi

PCYC_TIME=`$NDATE -1 $START_TIME`
if [[ ! -r ${RAPGES_PCYC}/rap_${PCYC_TIME}f001 &&  ! -r ${RAPBC}/wrfinput_d01_${time_str} ]]; then
    counter=1
    while [[ $counter -lt 19 ]]; do
     counterhr=$counter
     typeset -Z2 counterhr
     FCYC_TIME=`$NDATE -${counter} $START_TIME`
     if [ -r ${RAPGES_FCYC}/rap_${FCYC_TIME}f0$counterhr ]; then
      echo 'guess available' >> guess.out
      break
     fi
     counter=` expr $counter + 1 `
    done
else
    echo 'guess available' >> guess.out
fi

if [ ! -r guess.out ]; then
    echo 'FATAL ERROR: no first guess is available'
    echo 'please try a cycle divisible by 3'
    export err=9; err_chk
fi

#   First try to use a
#   guess from the full cycle

if [ ! -r wrf_inout ]; then
    counter=1
    while [[ $counter -lt 19 ]]; do
     counterhr=$counter
     typeset -Z2 counterhr
     FCYC_TIME=`$NDATE -${counter} $START_TIME`
     if [ -r ${RAPGES_FCYC}/rap_${FCYC_TIME}f0$counterhr ]; then
      echo "Process EnKF using rap_${FCYC_TIME}f0$counterhr"
      cp ${RAPGES_FCYC}/rap_${FCYC_TIME}f0$counterhr ./wrf_inout
      echo " Cycle ${YYYYMMDDHH}: Process EnKF background=rap_${FCYC_TIME}f0$counterhr"
      break
     fi
     counter=` expr $counter + 1 `
    done
fi

#  Attempt to use cold start if no guess has been found
if [ ! -r wrf_inout ]; then
   if [ -r "${RAPBC}/wrfinput_d01_${time_str}" ]; then
      echo "EnKF processing using ${RAPBC}/wrfinput_d01_${time_str} "
      cp ${RAPBC}/wrfinput_d01_${time_str} ./wrf_inout
   else
      echo "${RAPBC}/wrfinput_d01_${time_str} does not exist!!"
      echo "ERROR: No background file for EnKF processing at ${time_str}!!!!"
      echo " Cycle ${YYYYMMDDHH}: Process EnKF failed because of no background" 
      err_exit
   fi
fi

# Set fixed files
anavinfo=${FIXrap}/rap_anavinfo_arw_netcdf
processanl=${PARMrap}/rap_process_enkf.anl

# Fixed fields
cp $anavinfo anavinfo
cp $processanl namelist.input

## 
## Find closest GFS EnKF forecast to analysis time
##
COMINgfs=/gpfs/hps/ptmp/emc.glopara/com2/gfs/para
ENKF_FCST=${COMINgfs}
CYCSTART_TIME=`echo "${START_TIME}" | sed 's/\([[:digit:]]\{2\}\)$/ \1/'`

stampcycle=`date -d "${CYCSTART_TIME}" +%s`
minHourDiff=100
loops="009"
for loop in $loops; do
  #for timelist in `ls ${ENKF_FCST}/enkf.*/*/gdas_*.atmf${loop}s.mem080.nemsio`; do
    #availtime=`basename ${timelist} | cut -d'_' -f2`
  for timelist in `ls ${ENKF_FCST}/enkf.*/*/gdas*.atmf${loop}s.mem080.nemsio`; do
    availtimeyyyymmdd=`echo ${timelist} | cut -d'/' -f9 | cut -c 6-13`
    availtimehh=`echo ${timelist} | cut -d'/' -f10`
    availtime=${availtimeyyyymmdd}${availtimehh}
    AVAIL_TIME=`echo "${availtime}" | sed 's/\([[:digit:]]\{2\}\)$/ \1/'`
    AVAIL_TIME=`date -d "${AVAIL_TIME}"`

    stamp_avail=`date -d "${AVAIL_TIME} ${loop} hours" +%s`

    hourDiff=`echo "($stampcycle - $stamp_avail) / (60 * 60 )" | bc`;
    if [[ ${stampcycle} -lt ${stamp_avail} ]]; then
       hourDiff=`echo "($stamp_avail - $stampcycle) / (60 * 60 )" | bc`;
    fi

    if [[ ${hourDiff} -lt ${minHourDiff} ]]; then
       minHourDiff=${hourDiff}
       enkfcstname=gdas.t${availtimehh}z.atmf${loop}s
       EYYYYMMDD=$(echo ${availtime} | cut -c1-8)
       EHH=$(echo ${availtime} | cut -c9-10)
    fi
  done
done
ls ${ENKF_FCST}/enkf.${EYYYYMMDD}/${EHH}/${enkfcstname}.mem???.nemsio > filelist

export pgm=rap_process_enkf
. prep_step

startmsg
mpirun.lsf ${EXECrap}/rap_process_enkf >> $DATA/$pgmout 2>errfile 
export err=$?;err_chk

cp enspreproc_arw_mem* ${RAPGES_ENKF}

tar -cvf rap_enspreproc_${availtime}.tar enspreproc*
cp rap_enspreproc_${availtime}.tar $COMOUT/.

msg="JOB $job HAS COMPLETED NORMALLY."
postmsg "$jlogfile" "$msg"

exit 0
