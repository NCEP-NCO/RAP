#!/bin/ksh -l
################################################################################
####  UNIX Script Documentation Block
#                      .                                             .
# Script name:       exrap_analysis_pcyc.sh.ecf
# Script description:  runs the GSI for the RAP partial cycle
#
# Author:   Ming Hu / Geoff Manikin / Julia Zhu  Org: EMC          Date: 2011-10-01
# 2011-10-01  M Hu / G Manikin / J Zhu
# 2013-01-10  G Manikin - adapted for WCOSS
# 2013-05-30  M Hu / G Manikin - use EnKF

set -x

cd $DATA

# Set up some constants
export HOMErap=${HOMErap:-/nwprod/rap.${ver}}
export PARMrap=${PARMrap:-$HOMErap/parm}
export FIXrap=${FIXrap:-$HOMErap/fix}
export EXECrap=${EXECrap:-$HOMErap/exec}
export COMGFS=${COMGFS:-/com/gfs/prod}
export ndate=${ndate:-/nwprod/util/exec/ndate}

# Directory for the CRTM files:
export FIXcrtm=${FIXcrtm:-/nwprod/fix}

export WPSNAMELIST=namelist.wps
START_TIME=$PDY$cyc
echo $START_TIME >STARTTIME

# Compute date & time components for the analysis time
ymd=`echo ${START_TIME} | cut -c1-8`
ymdh=`echo ${START_TIME} | cut -c1-10`
mdh=`echo ${START_TIME} | cut -c5-10`
hh=`echo ${START_TIME} | cut -c9-10`

# Set up some NCEP loadlevelor environment variables
export SPINLOOPTIME=10000
export YIELDLOOPTIME=40000
export AIXTHREAD_SCOPE=S
export MALLOCMULTIHEAP=true
export MEMORY_AFFINITY=MCM
export BIND_TASKS=YES

export MP_EAGER_LIMIT=165536
export MP_COREFILE_FORMAT=lite
export MP_EUIDEVELOP=min
export MP_EUILIB=us
export MP_MPILIB=mpich2

export MP_LABELIO=yes
export MP_SHARED_MEMORY=yes

export MPICH_ALLTOALL_THROTTLE=0
export KMP_STACKSIZE=1024m
export MP_TASK_AFFINITY=cpu:2
export OMP_NUM_THREADS=2

# Set up some constants
export RAPGES_FCYC=${RAPGES_FCYC:-$gespath/rap/rapges}
export RAPGES_PCYC=${RAPGES_PCYC:-$gespath/rap/rapges_pcyc}
export RAPGES_SFC=${RAPGES_SFC:-$gespath/rap/rapges_sfc}
export RAPBC=${RAPBC:-$gespath/rap/rapbc}
export PREPDIR=${PREPDIR:-/com/${NET}/prod}

# Compute date & time components for the analysis time
YYYY=`echo ${START_TIME} | cut -c1-4`
MM=`echo ${START_TIME} | cut -c5-6`
DD=`echo ${START_TIME} | cut -c7-8`
HH=`echo ${START_TIME} | cut -c9-10`
yy=`echo ${START_TIME} | cut -c3-4`
YYYYMMDDHH=${YYYY}${MM}${DD}${HH}
YYYYMMDD=${YYYY}${MM}${DD}

# Compute date & time components for the analysis time minus 1 day
DDm1=`$ndate -24 $START_TIME`
YMDm1=`echo ${DDm1} | cut -c1-8`

# Create the ram work directory and cd into it
workdir=$DATA/gsiprd
rm -rf ${workdir}
mkdir -p ${workdir}
cd ${workdir}
/nwprod/util/ush/setup.sh

logfile=gsi.out

# Bring over background field (it's modified by GSI so we can't link to it)
time_str=${YYYY}-${MM}-${DD}_${HH}:00:00
echo " time_str = ${time_str}"

#  check to see if a first guess is available in the pcyc guess directory 
PCYC_TIME=`$ndate -1 $START_TIME`
if [ -r ${RAPGES_PCYC}/rap_${PCYC_TIME}f001 ]; then
   cp ${RAPGES_PCYC}/rap_${PCYC_TIME}f001 ./wrf_inout
   echo " Cycle ${YYYYMMDDHH}: GSI partially cycled start with rap_${PCYC_TIME}f001"
fi

# attempt cold start if no guess has been found;  this option will be used
#   at the start of the partial cycle (03 and 15z);   note that if there is
#   no pcyc guess available at a cycle time not divisible by 3, there isn't
#   anything that can be done.   The best hope is to restart the partial cycle
#   with a cold start at 06 or 18z

if [ ! -r wrf_inout ]; then
   if [ -r "${RAPBC}/wrfinput_d01_${time_str}" ]; then
      echo "Cold Start with ${RAPBC}/wrfinput_d01_${time_str} "
      cp ${RAPBC}/wrfinput_d01_${time_str} ./wrf_inout
      echo " Cycle ${YYYYMMDDHH}: GSI cold start with wrfout_d01_${time_str}"
## cycle surface variables
      if [ -r "${RAPGES_SFC}/wrfout_d01_${HH}" ]; then
          echo "cycle Surface fields based on ${RAPGES_SFC}/wrfout_d01_${HH} "
          cp ${RAPGES_SFC}/wrfout_d01_${HH} ./wrfoutSfc
          mpirun.lsf ${EXECrap}/rap_full_cycle_surface >> $DATA/$pgmout 2>errfile 
          export err=$?; err_chk
      else
          echo "${RAPGES_SFC}/wrfout_d01_${HH} does not exist!!"
          echo "WARNING: no surface data cycled for background at ${time_str}!!!!"
      fi
   else
      echo "${RAPBC}/wrfinput_d01_${time_str} does not exist!!"
      echo "ERROR: no background file for analaysis at ${time_str}!!!!"
      echo " Cycle ${YYYYMMDDHH}: GSI failed because of no background"
      err_exit
   fi
fi

# we now update the SST for all cycles
  echo "update SST "
  NCEPSST=$COMGFS/sst.${YYYYMMDD}
  NCEPSST2=$COMGFS/sst.${YMDm1}
  cp ${FIXrap}/rap_RTG_SST_landmask.dat ./RTG_SST_landmask.dat
  cp ${FIXrap}/rap_geo_em.d01.int  ./geo_em.d1
  if [ -r "${NCEPSST}/rtgssthr_grb_0.083" ]; then
    cp ${NCEPSST}/rtgssthr_grb_0.083 SSTRTG
    cp ${NCEPSST}/sst2dvar.t12z.nam_grid SST14km
    mpirun.lsf ${EXECrap}/rap_process_sst >> $DATA/$pgmout 2>errfile
    export err=$?; err_chk
  elif [ -r "${NCEPSST2}/rtgssthr_grb_0.083" ]; then
    cp ${NCEPSST2}/rtgssthr_grb_0.083 SSTRTG
    cp ${NCEPSST2}/sst2dvar.t12z.nam_grid SST14km
    mpirun.lsf ${EXECrap}/rap_process_sst >> $DATA/$pgmout 2>errfile
    export err=$?; err_chk
  else
    echo "NOTE: no SST data available for ${HH}z cycle!"
  fi

## trim snow
trim_snow='15'
if [ ${HH} -eq ${trim_snow} ]; then
  if [ -r "${PREPDIR}/rap.${YYYYMMDD}/rap.t${HH}z.imssnow" ]; then
     echo "trim snow based on imssnow "
     cp  ${PREPDIR}/rap.${YYYYMMDD}/rap.t${HH}z.imssnow ./imssnow
     cp  ${FIXrap}/rap_geo_em.d01.int ./geo_em.d1 
     mpirun.lsf ${EXECrap}/rap_process_imssnow >> imssnow.out
     export err=$?; err_chk
  else
    echo "${COMIN}/rap.t${HH}z.imssnow does not exist!!"
    echo "no snow file available at for ${HH}z cycle!!!!"
  fi
else
  echo "NOTE: we do not trim snow during this cycle!"
fi

# prepbufr section
ln -s ${PREPDIR}/${RUN}.${YYYYMMDD}/${RUN}.t${HH}z.prepbufr.tm00 ./prepbufr

if [ -r "${PREPDIR}/rap.${YYYYMMDD}/rap.t${HH}z.mosaic.bufr" ]; then
  ln -s ${PREPDIR}/rap.${YYYYMMDD}/rap.t${HH}z.mosaic.bufr ./refInGSI
else
  echo "Warning: Processed Mosaic data not available"
fi

if [ -r "${PREPDIR}/rap.${YYYYMMDD}/rap.t${HH}z.nasacloud.bufr" ]; then
  ln -s ${PREPDIR}/rap.${YYYYMMDD}/rap.t${HH}z.nasacloud.bufr ./larcInGSI
else
  echo "Warning: Processed Cloud data not available"
fi

if [ -r "${PREPDIR}/${RUN}.${YYYYMMDD}/rap_p.t${HH}z.1bamua.tm00.bufr_d" ]; then
  ln -s ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bamua.tm00.bufr_d ./amsuabufr
else
  echo "Warning: ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bamua.tm00.bufr_d is not available
"
fi

if [ -r "${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bamub.tm00.bufr_d" ]; then
  ln -s ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bamub.tm00.bufr_d ./amsubbufr
else
  echo "Warning: ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bamub.tm00.bufr_d is not available
"
fi

if [ -r "${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bhrs3.tm00.bufr_d" ]; then
  ln -s ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bhrs3.tm00.bufr_d ./hirs3bufr
else
  echo "Warning: ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bhrs3.tm00.bufr_d is not available
"
fi

if [ -r "${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bhrs4.tm00.bufr_d" ]; then
  ln -s ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bhrs4.tm00.bufr_d ./hirs4bufr
else
  echo "Warning: ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bhrs4.tm00.bufr_d is not available
"
fi

if [ -r "${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bmhs.tm00.bufr_d" ]; then
  ln -s ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bmhs.tm00.bufr_d ./mhsbufr
else
  echo "Warning: ${PREPDIR}/rap_p.${YYYYMMDD}/rap_p.t${HH}z.1bmhs.tm00.bufr_d is not available"
fi

# Set fixed files
#   berror   = forecast model background error statistics
#   specoef  = CRTM spectral coefficients
#   trncoef  = CRTM transmittance coefficients
#   emiscoef = CRTM coefficients for IR sea surface emissivity model
#   aerocoef = CRTM coefficients for aerosol effects
#   cldcoef  = CRTM coefficients for cloud effects
#   satinfo  = text file with information about assimilation of brightness temperatures
#   satangl  = angle dependent bias correction file (fixed in time)
#   pcpinfo  = text file with information about assimilation of prepcipitation rates
#   ozinfo   = text file with information about assimilation of ozone data
#   errtable = text file with obs error for conventional data (regional only)
#   convinfo = text file with information about assimilation of conventional data
#   bufrtable= text file ONLY needed for single obs test (oneobstest=.true.)
#   bftab_sst= bufr table for sst ONLY needed for sst retrieval (retrieval=.true.)

anavinfo=${FIXrap}/rap_anavinfo_arw_netcdf
BERROR=${FIXrap}/rap_berror_stats_global
SATANGL=${FIXrap}/rap_global_satangbias.txt
SATINFO=${FIXrap}/rap_global_satinfo.txt
RTMFIX=${FIXcrtm}/crtm_2.0.5

RTMEMIS=${RTMFIX}/EmisCoeff/Big_Endian/EmisCoeff.bin
RTMAERO=${RTMFIX}/AerosolCoeff/Big_Endian/AerosolCoeff.bin
RTMCLDS=${RTMFIX}/CloudCoeff/Big_Endian/CloudCoeff.bin
CONVINFO=${FIXrap}/rap_nam_regional_convinfo
OZINFO=${FIXrap}/rap_global_ozinfo.txt    
PCPINFO=${FIXrap}/rap_global_pcpinfo.txt

OBERROR=${FIXrap}/rap_nam_errtable.r3dv
AIRCRAFTREJECTLIST=${FIXrap}/rap_current_bad_aircraft.txt   # aircraft reject list

# Fixed fields
 cp $anavinfo anavinfo
 cp $BERROR   berror_stats
 cp $SATANGL  satbias_angle
 cp $SATINFO  satinfo
 cp $RTMEMIS  EmisCoeff.bin
 cp $RTMAERO  AerosolCoeff.bin
 cp $RTMCLDS  CloudCoeff.bin
 cp $CONVINFO convinfo
 cp $OZINFO   ozinfo
 cp $PCPINFO  pcpinfo
 cp $OBERROR  errtable
 cp $AIRCRAFTREJECTLIST current_bad_aircraft
# 
#    # CRTM Spectral and Transmittance coefficients
    nsatsen=`cat satinfo | wc -l`
    isatsen=1
    while [[ $isatsen -le $nsatsen ]]; do
       flag=`head -n $isatsen satinfo | tail -1 | cut -c1-1`
       if [[ "$flag" != "!" ]]; then
          satsen=`head -n $isatsen satinfo | tail -1 | cut -f 2 -d" "`
          spccoeff=${satsen}.SpcCoeff.bin
          if  [[ ! -s $spccoeff ]]; then
             cp $RTMFIX/SpcCoeff/Big_Endian/$spccoeff $spccoeff
             cp $RTMFIX/TauCoeff/Big_Endian/${satsen}.TauCoeff.bin ${satsen}.TauCoeff.bin
          fi
       fi
       isatsen=` expr $isatsen + 1 `
    done

# Only need this file for single obs test
 bufrtable=${PARMrap}/rap_prepobs.bufrtable
 cp $bufrtable ./prepobs_prep.bufrtable

## 
## Find closest GFS EnKF forecast to analysis time
##
ENKF_FCST=${COMGFS}
CYCSTART_TIME=`echo "${START_TIME}" | sed 's/\([[:digit:]]\{2\}\)$/ \1/'`

stampcycle=`date -d "${CYCSTART_TIME}" +%s`
minHourDiff=100
loops="06 09"
for loop in $loops; do
  for timelist in `ls ${ENKF_FCST}/enkf.*/*/sfg_*_fhr${loop}s_mem080`; do
    availtime=`basename ${timelist} | cut -d'_' -f2`
    AVAIL_TIME=`echo "${availtime}" | sed 's/\([[:digit:]]\{2\}\)$/ \1/'`
    AVAIL_TIME=`date -d "${AVAIL_TIME}"`

    stamp_avail=`date -d "${AVAIL_TIME} ${loop} hours" +%s`

    hourDiff=`echo "($stampcycle - $stamp_avail) / (60 * 60 )" | bc`;
    if [[ ${stampcycle} -lt ${stamp_avail} ]]; then
       hourDiff=`echo "($stamp_avail - $stampcycle) / (60 * 60 )" | bc`;
    fi

    if [[ ${hourDiff} -lt ${minHourDiff} ]]; then
       minHourDiff=${hourDiff}
       enkfcstname=sfg_${availtime}_fhr${loop}s
       EYYYYMMDD=$(echo ${availtime} | cut -c1-8)
       EHH=$(echo ${availtime} | cut -c9-10)
    fi
  done
done
ls ${ENKF_FCST}/enkf.${EYYYYMMDD}/${EHH}/${enkfcstname}_* > filelist

nummem=70
beta1_inv=1.0
ifhyb=.false.
if [[ ${hourDiff} -lt 6 ]]; then
  nummem=`more filelist | wc -l`
  nummem=$((nummem -3 ))
  if [[ ${nummem} -ge 40 ]]; then
    echo "Do hybrid with ${enkfcstname}"
    beta1_inv=0.5
    ifhyb=.true.
    echo " Cycle ${YYYYMMDDHH}: GSI hybrid uses ${enkfcstname} with n_ens=${nummem}"
  fi
fi

# Set some parameters for use by the GSI executable and to build the namelist
export JCAP=62
export LEVS=60
export DELTIM=${DELTIM:-$((3600/($JCAP/20)))}

grid_ratio=2
cloudanalysistype=7

# Build the GSI namelist on-the-fly
. ${PARMrap}/rap_gsiparm.anl.sh
cat << EOF > gsiparm.anl
$gsi_namelist
EOF

cp ${FIXrap}/rap_ndas.t06z.satbias.tm03 ./satbias_in
export pgm=rap_gsi
. prep_step

startmsg
mpirun.lsf ${EXECrap}/rap_gsi < gsiparm.anl >> $DATA/$pgmout 2>errfile 
export err=$?; err_chk

cp gsiparm.anl gsiparm.anl_var
mv fort.201 fit_p1
mv fort.202 fit_w1
mv fort.203 fit_t1
mv fort.204 fit_q1
mv fort.205 fit_pw1
mv fort.206 fit_oz1
mv fort.207 fit_rad1
mv fort.208 fit_pcp1
mv fort.209 fit_rw1
mv fort.213 fit_sst1

cat fit_p1 fit_w1 fit_t1 fit_q1 fit_pw1 fit_rad1 fit_rw1 > ${COMOUT}/rap.t${cyc}z.fits.${tmmark}
cat fort.210 fort.211 fort.212 fort.214 fort.215 fort.217 fort.220 > ${COMOUT}/rap.t${cyc}z.fits2.${tmmark}

cp satbias_out ${COMOUT}/rap.t${cyc}z.satbias.${tmmark}

grid_ratio=1
cloudanalysistype=3
ifhyb=.false.

# Build the GSI namelist on-the-fly
. ${PARMrap}/rap_gsiparm.anl.sh
cat << EOF > gsiparm.anl
$gsi_namelist
EOF

export pgm=rap_gsi
startmsg
mpirun.lsf ${EXECrap}/rap_gsi < gsiparm.anl >> $DATA/$pgmout 2>errfile
export err=$?; err_chk

cp gsiparm.anl gsiparm.anl_cloud
cp wrf_inout ${COMOUT}/rap.t${cyc}z.wrf_inout_pcyc

msg="JOB $job HAS COMPLETED NORMALLY."
postmsg "$jlogfile" "$msg"

exit 0
