#!/bin/ksh -l
################################################################################
####  UNIX Script Documentation Block
#                      .                                             .
# Script name:       exrap_analysis_sh.ecf
# Script description:  runs the GSI and boundary update for the RAP cycle
#
# Author:   Ming Hu / Geoff Manikin / Julia Zhu  Org: EMC       Date: 2011-10-01
#
# Script history log:
# 2011-10-01  M Hu / G Manikin / J Zhu
# 2018-01-25  B Blake / C Guastini / G Manikin / C Alexander - RAPv4

set -x

cd $DATA

# Set up some constants

START_TIME=`$NDATE 9 $PDY$cyc`
echo $START_TIME >STARTTIME

### Now run the GSI
# Set up some NCEP loadlevelor environment variables
export SPINLOOPTIME=10000
export YIELDLOOPTIME=40000
export AIXTHREAD_SCOPE=S
export MALLOCMULTIHEAP=true
export MEMORY_AFFINITY=MCM
export BIND_TASKS=YES

export MP_EAGER_LIMIT=165536
export MP_COREFILE_FORMAT=lite
export MP_EUIDEVELOP=min
export MP_EUILIB=us
export MP_MPILIB=mpich2

export MP_LABELIO=yes
export MP_USE_BULK_XFER=yes
export MP_SHARED_MEMORY=yes

export MPICH_ALLTOALL_THROTTLE=0
export KMP_STACKSIZE=1024m
export MP_TASK_AFFINITY=cpu:2
export OMP_NUM_THREADS=2

# Set to yes for faster collective ops (mpi_reduce)
# but may not yield bitwise identical results from
# run to run when yes.
export MP_COLLECTIVE_OFFLOAD=no

# Compute date & time components for the analysis time
YYYY=`echo ${START_TIME} | cut -c1-4`
MM=`echo ${START_TIME} | cut -c5-6`
DD=`echo ${START_TIME} | cut -c7-8`

# Bring over background field
time_str=${YYYY}-${MM}-${DD}_${cyc}_00_00
echo " time_str = ${time_str}"

# first step is to make sure that we aren't attempting a cold start
#   at a cycle time that won't be possible.   These are all cycle times
#   not divisible by 3, as we use boundary files which are generated by
#   3-hrly GFS output

let mod=${cyc}%3
echo mod 
echo $mod 
if [[ ${mod} -ne '0' ]]; then
  echo 'a cold start will not be possible this cycle if needed'
fi

PCYC_TIME=`$NDATE -1 $START_TIME`
if [[ ! -r ${RAPGES_PCYC}/rap_${PCYC_TIME}f001 &&  ! -r ${RAPBC}/wrfinput_d01_${time_str} ]]; then
    counter=1
    while [[ $counter -lt 19 ]]; do
     counterhr=$counter
     typeset -Z2 counterhr
     FCYC_TIME=`$NDATE -${counter} $START_TIME`
     if [ -r ${RAPGES_FCYC}/rap_${FCYC_TIME}f0$counterhr ]; then
      echo 'guess available' >> guess.out
      break
     fi
     counter=` expr $counter + 1 `
    done
else
    echo 'guess available' >> guess.out
fi

if [ ! -r guess.out ]; then
    echo 'FATAL ERROR: no first guess is available'
    echo 'please try a cycle divisible by 3'
    export err=9; err_chk
fi

# read in grid specs
cp ${FIXhrrr}/rap_gridspecs ./wrf_inout

# Set fixed files
anavinfo=${FIXrap}/rap_anavinfo_arw_netcdf
processanl=${PARMrap}/rap_process_enkf.anl

# Fixed fields
cp $anavinfo anavinfo
cp $processanl namelist.input

## 
## Find closest GFS EnKF forecast to analysis time
##
CYCSTART_TIME=`echo "${START_TIME}" | sed 's/\([[:digit:]]\{2\}\)$/ \1/'`

stampcycle=`date -d "${CYCSTART_TIME}" +%s`
minHourDiff=100
loops="009"
for loop in $loops; do
  for timelist in `ls ${COMINgfs}/enkf.*/*/gdas*.atmf${loop}s.mem080.nemsio`; do
    availtimeyyyymmdd=`echo ${timelist} | cut -d'/' -f9 | cut -c 6-13`
    availtimehh=`echo ${timelist} | cut -d'/' -f10`
    availtime=${availtimeyyyymmdd}${availtimehh}
    AVAIL_TIME=`echo "${availtime}" | sed 's/\([[:digit:]]\{2\}\)$/ \1/'`
    AVAIL_TIME=`date -d "${AVAIL_TIME}"`

    stamp_avail=`date -d "${AVAIL_TIME} ${loop} hours" +%s`

    hourDiff=`echo "($stampcycle - $stamp_avail) / (60 * 60 )" | bc`;
    if [[ ${stampcycle} -lt ${stamp_avail} ]]; then
       hourDiff=`echo "($stamp_avail - $stampcycle) / (60 * 60 )" | bc`;
    fi

    if [[ ${hourDiff} -lt ${minHourDiff} ]]; then
       minHourDiff=${hourDiff}
       enkfcstname=gdas.t${availtimehh}z.atmf${loop}s
       EYYYYMMDD=$(echo ${availtime} | cut -c1-8)
       EHH=$(echo ${availtime} | cut -c9-10)
    fi
  done
done
ls ${COMINgfs}/enkf.${EYYYYMMDD}/${EHH}/${enkfcstname}.mem???.nemsio > filelist01

export pgm=rap_process_enkf
#. prep_step

#startmsg
cp ${EXECrap}/rap_process_enkf .
runline="aprun -n 120 -N 12 ./rap_process_enkf"
$runline >> $DATA/$pgmout 2>errfile
#export err=$?;err_chk

cp enspreproc_arw_mem* ${RAPGES_ENKF}

tar -cvf rap_enspreproc_${availtime}.tar enspreproc*
cp rap_enspreproc_${availtime}.tar $COMOUT/.

msg="JOB $job HAS COMPLETED NORMALLY."
postmsg "$jlogfile" "$msg"

exit 0
